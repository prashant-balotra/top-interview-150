Problem Link: https://leetcode.com/problems/clone-graph/?envType=study-plan-v2&envId=top-interview-150

```
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/

class Solution {
    public Node cloneGraph(Node node) {
        if(node!=null) {
            Map<Integer, Node> oldToNew = new HashMap<>();
            return dfs(node, oldToNew);
        }

        return node;
    }

    Node dfs(Node node, Map<Integer, Node> oldToNew) {
        if(oldToNew.containsKey(node.val)) {
            return oldToNew.get(node.val);
        }

        Node copy = new Node(node.val);
        oldToNew.put(copy.val, copy);

        for(Node n: node.neighbors) {
            copy.neighbors.add(dfs(n, oldToNew));
        }
        return copy;
    }
}
```

This approach is a Depth-First Search (DFS) because of its recursive nature, which naturally explores the graph by going as deep as possible down one path before backtracking.

Think of it like navigating a maze. In a DFS approach, you'd follow one path until you hit a dead end, then backtrack to the last junction and try a different path. Your code does exactly this.

How Your Code Follows the DFS Pattern
Start at a Node: The process begins with the initial node. A copy is created, and it's placed in the oldToNew map to mark it as "being visited."

Go Deep: The code then iterates through the first neighbor of the original node and immediately makes a recursive call: dfs(neighbor, oldToNew). This is the "depth" part of the search. The code doesn't look at the second or third neighbors yet; it immediately dives deeper into the graph starting from that first neighbor.

Follow the Path: Inside that recursive call, it does the same thing: clones the neighbor and then immediately calls dfs on its first neighbor. This continues, creating a chain of recursive calls that goes deeper and deeper into the graph along a single path.

Hit a "Dead End" (or a Visited Node): The recursion stops deepening when it encounters a node that has already been cloned (i.e., it's in the oldToNew map). This is the equivalent of hitting a dead end or a previously visited part of the maze. The function then returns the existing copy of that node.

Backtrack and Explore Other Paths: After a recursive call returns, the for loop continues to the next neighbor of the previous node. It then dives deep down that new path. This process of returning from a recursive call and moving to the next item in a loop is the "backtracking" step.
